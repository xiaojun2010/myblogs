AQS是一个用于构建锁、同步器、协作工具类的工具类（框架）



# AQS原理解析

AQS最核心的三大部分：

- **<font color='red'>state</font>**
- 控制线程枪锁和配合的<font color='red'>**FIFO队列**</font>
- 期望协作工具类去实现的<font color='red'>**获取/释放**</font>等重要方法



## state 状态

```java
private volatile int state;
```



## 控制线程枪锁和配合的<font color='red'>**FIFO队列**</font>

AQS维护一个等待队列（双向链表形式），把线程放到这个队列里



## 期望协作工具类去实现的<font color='red'>**获取/释放**</font>等重要方法

协作类自己实现

# 5. AQS中为什么头结点是为空的

头结点可以简单理解就是可以不用参加排队，表示已经获取到锁的线程，已经在aqs类中已经记录绑定获取到锁的线程，所以head结点直接设置线程为null，防止浪费空间内存。

# 6. 非公平锁实现原理

获取锁：

1. 使用cas 修改锁的状态0改成1；
2. 如果使用cas修改成功，则当前aqs exclusiveOwnerThread 记录当前线程获取锁。
3. 如果当前线程重复获取锁，则当前aqs状态+1 重入锁实现。
4. 如果使用cas 修改失败，则当前线程使用cas 在aqs双向链表尾部追加当前线程，同时当前线程也会阻塞 使用 LockSupport

释放锁：

1. 当前aqs状态 -releases 如果 为0 则会释放锁；
2. 使用cas 修改AQS的状态
3. 唤醒阻塞队列中头节点下一个节点阻塞线程从新进入到竞争锁状态
4. 唤醒的线程cas操作成功，则会从双向中移除。

注意：如果在没有其他的线程竞争锁时，则aqs 类中 head 节点是为null

# 7. 公平锁实现原理

公平锁与非公平锁的实现原理区别：

1. 非公平锁调用lock方法，首先会执行一次CAS操作、如果CAS成功则当前线程获取到锁 ，如果CAS失败之后，在重试的过程中如果AQS锁的状态为0，则可以继续执行CAS操作。
2. 公平锁调用lock方法，如果已经有其他线程获取到该锁，则当前线程直接追加双向链表后面，不会参与CAS操作。